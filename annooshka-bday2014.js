// Generated by CoffeeScript 1.6.3
(function() {
  var Background, Ball, Block, Scene, balls_count, blocks_map, generate_ball, init, parse_blocks,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  blocks_map = ['0000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000\n0000000000000000033333000003333300000000000000000\n0000000333330000300000330330000030033333003333300\n0000003000030000300000003000000030000300030000300\n0000000333330000033000000000003300000300003333300\n0000000003030000000330000000330000000300000030300\n0000000330030000000003300033000000000300003300300\n0000000000000000000000030300000000000000000000000\n0000000000000000000000003000000000000000000000000\n0000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000', '0000000000000000000000000000000000000000000000000\n0000000011110000011100100010111101000001000000000\n0000000010000000100100100010100001100011000000000\n0000000010000000100100111110111001010101000000000\n0000000010000000111100100010100001001001000000000\n0000000011110001000010100010111101000001000000000\n0000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000\n0011110111110101010001110011110100010100010111100\n0010010100010011100010010010000100010100110100100\n0011110100010001000010010011100111110101010111100\n0010000100010011100011110010000100010110010001100\n0010000111110101010100001011110100010100010110100\n0000000000000000000000000000000000000000000000000'];

  Background = (function() {
    function Background(color) {
      this.color = color;
    }

    Background.prototype.redraw = function(ctx) {
      ctx.fillStyle = this.color;
      return ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    };

    return Background;

  })();

  Block = (function() {
    function Block(x, y, radius, type) {
      this.x = x;
      this.y = y;
      this.radius = radius;
      this.type = type;
      this.block = true;
    }

    Block.prototype.shot = function() {
      if (this.type !== 2) {
        return this.type = Math.max(-1, this.type - 1);
      }
    };

    Block.prototype.visible = function() {
      return this.type !== -1;
    };

    Block.prototype.redraw = function(ctx) {
      switch (this.type) {
        case 1:
        case 4:
          ctx.fillStyle = "#6363c7";
          break;
        case 2:
          ctx.fillStyle = "#ff2020";
          break;
        case 0:
        case 3:
          ctx.fillStyle = "#83ff53";
          break;
        case -1:
          return;
      }
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);
      ctx.closePath();
      return ctx.fill();
    };

    Block.build_blocks_from_map = function(map, sx, sy, radius) {
      var blocks, blocks_line, ix, iy, line, n, _i, _j, _len, _len1;
      blocks = [];
      iy = 0.5;
      for (_i = 0, _len = map.length; _i < _len; _i++) {
        line = map[_i];
        ix = 0.5;
        blocks_line = [];
        for (_j = 0, _len1 = line.length; _j < _len1; _j++) {
          n = line[_j];
          blocks.push(new Block(sx + ix * radius * 2, sy + iy * radius * 2, radius, n));
          ix += 1;
        }
        iy += 1;
      }
      return blocks;
    };

    return Block;

  })();

  Ball = (function() {
    function Ball(x, y, dx, dy, radius) {
      this.x = x;
      this.y = y;
      this.dx = dx;
      this.dy = dy;
      this.radius = radius;
      this.ball = true;
      this.collided = [];
    }

    Ball.prototype.distance = function(obj) {
      return Math.sqrt(Math.pow(this.x - obj.x, 2) + Math.pow(this.y - obj.y, 2));
    };

    Ball.prototype.check_collision = function(obj) {
      return this.distance(obj) <= this.radius + obj.radius;
    };

    Ball.projection = function(x1, y1, x2, y2, x3, y3, direction) {
      var cos, l, nx, ny, sin;
      l = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
      sin = (y2 - y1) / l;
      cos = (x2 - x1) / l;
      nx = x3 * cos + y3 * sin;
      ny = -x3 * sin + y3 * cos;
      return [nx, ny];
    };

    Ball.collide = function(o1, o2) {
      var beat1, beat2, static1, static2, _ref, _ref1, _ref2, _ref3;
      _ref = Ball.projection(o1.x, o1.y, o2.x, o2.y, o1.dx, o1.dy), beat1 = _ref[0], static1 = _ref[1];
      _ref1 = Ball.projection(o1.x, o1.y, o2.x, o2.y, o2.dx, o2.dy), beat2 = _ref1[0], static2 = _ref1[1];
      _ref2 = Ball.projection(o1.x, o2.y, o2.x, o1.y, beat2, static1), o1.dx = _ref2[0], o1.dy = _ref2[1];
      return _ref3 = Ball.projection(o1.x, o2.y, o2.x, o1.y, beat1, static2), o2.dx = _ref3[0], o2.dy = _ref3[1], _ref3;
    };

    Ball.symmetric_collide = function(o, x, y) {
      var beat, stat, _ref, _ref1;
      _ref = Ball.projection(o.x, o.y, x, y, o.dx, o.dy), beat = _ref[0], stat = _ref[1];
      return _ref1 = Ball.projection(o.x, y, x, o.y, -beat, stat), o.dx = _ref1[0], o.dy = _ref1[1], _ref1;
    };

    Ball.prototype.calc_collisions = function(objs, w, h) {
      var ncollided, o, _i, _len, _ref,
        _this = this;
      ncollided = [];
      _ref = objs.filter(function(o) {
        return _this !== o && _this.check_collision(o);
      });
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        if (__indexOf.call(this.collided, o) < 0) {
          if (o.ball) {
            if (__indexOf.call(o.collided, this) < 0) {
              Ball.collide(this, o);
              this.collided.push(o);
            }
          } else if (o.block && o.visible()) {
            Ball.symmetric_collide(this, o.x, o.y);
            o.shot();
            if (balls_count < 22) {
              balls_count += 1;
              objs.push(generate_ball(this.radius, w, h));
            }
          }
        }
        ncollided.push(o);
      }
      this.collided = ncollided;
      if (this.x < this.radius && this.dx < 0) {
        Ball.symmetric_collide(this, -10, this.y);
      }
      if (this.x > w - this.radius && this.dx > 0) {
        Ball.symmetric_collide(this, w + 10, this.y);
      }
      if (this.y < this.radius && this.dy < 0) {
        Ball.symmetric_collide(this, this.x, -10);
      }
      if (this.y > h - this.radius && this.dy > 0) {
        return Ball.symmetric_collide(this, this.x, h + 10);
      }
    };

    Ball.prototype.step = function(ctx) {
      this.x += this.dx;
      return this.y += this.dy;
    };

    Ball.prototype.redraw = function(ctx) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);
      ctx.lineTo(this.x, this.y);
      ctx.closePath();
      ctx.fillStyle = "#63bfc7";
      return ctx.fill();
    };

    return Ball;

  })();

  generate_ball = function(radius, w, h) {
    var y;
    if (Math.random() < 0.5) {
      y = h / 8 * (7 + Math.random());
    } else {
      y = h / 8 * Math.random();
    }
    return new Ball(radius + (w - 2 * radius) * Math.random(), y, h * 0.01 * (Math.random() * 2 - 1), h * 0.01 * (Math.random() * 2 - 1), radius);
  };

  Scene = (function() {
    function Scene(ctx, objects, w, h, interval) {
      this.ctx = ctx;
      this.objects = objects;
      this.w = w;
      this.h = h;
      this.interval = interval != null ? interval : 100;
      this.stop = __bind(this.stop, this);
      this.iteration = __bind(this.iteration, this);
      this.timer = setInterval(this.iteration, this.interval);
    }

    Scene.prototype.iteration = function() {
      var _this = this;
      this.objects.forEach(function(o) {
        return typeof o.calc_collisions === "function" ? o.calc_collisions(_this.objects, _this.w, _this.h) : void 0;
      });
      this.objects.forEach(function(o) {
        return typeof o.step === "function" ? o.step(_this.ctx) : void 0;
      });
      return this.objects.forEach(function(o) {
        return o.redraw(_this.ctx);
      });
    };

    Scene.prototype.stop = function() {
      return clearInterval(this.timer);
    };

    return Scene;

  })();

  parse_blocks = function(blocks_map, w, h) {
    var block, block_diameter, ch, lindex, line, map, rindex, _i, _j, _k, _len, _len1, _len2, _ref;
    map = [];
    for (_i = 0, _len = blocks_map.length; _i < _len; _i++) {
      block = blocks_map[_i];
      lindex = 0;
      _ref = block.split("\n");
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        line = _ref[_j];
        if (map.length <= lindex) {
          map.push([]);
        }
        rindex = 0;
        for (_k = 0, _len2 = line.length; _k < _len2; _k++) {
          ch = line[_k];
          if (map[lindex].length <= rindex) {
            map[lindex].push(parseInt(ch));
          } else {
            map[lindex][rindex] += parseInt(ch);
          }
          rindex += 1;
        }
        lindex += 1;
      }
    }
    block_diameter = Math.min(w / map[0].length, h / map.length / 4 * 3);
    return [map, block_diameter / 2];
  };

  balls_count = 1;

  init = function() {
    var blocks, ctx, g, h, objects, radius, sx, sy, w, _ref,
      _this = this;
    $("body").css("background", "#293134");
    ctx = $("#area")[0].getContext("2d");
    w = $(window).width() - 20;
    h = $(window).height() - 20;
    ctx.canvas.width = w;
    ctx.canvas.height = h;
    _ref = parse_blocks(blocks_map, w, h), blocks = _ref[0], radius = _ref[1];
    sx = (w - blocks[0].length * 2 * radius) / 2;
    sy = (h - blocks.length * 2 * radius) / 2;
    objects = [].concat(new Background("#293134"), Block.build_blocks_from_map(blocks, sx, sy, radius));
    objects.push(generate_ball(radius, w, h));
    g = new Scene(ctx, objects, w, h);
    return $(window).resize(function() {
      g.stop();
      return init();
    });
  };

  $(init);

}).call(this);
